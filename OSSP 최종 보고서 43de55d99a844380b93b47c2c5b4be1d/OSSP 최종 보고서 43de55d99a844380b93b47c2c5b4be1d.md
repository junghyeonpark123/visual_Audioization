# OSSP 최종 보고서

분반: 02분반

                                                                                            

                                                                                 　　　 학과: 컴퓨터 공학과

                                                                                 　　　 성명: 박정현

### 주제

- 시각의 청각화 (visual audioization)

      명화를 음악으로

### 필요성 및 기대효과

시각 장애인들이 그림을 보는 대신 들을 수 있도록 함.

일반 사용자들은 원하는 이미지를 입력함으로써 연상 되는 멜로디의 음악을 출력 할 수 있음.

### 진행과정( 깃랩+깃허브의 히스토리 기준): 본인 깃랩 주소 기록

[http://sw-git.chosun.ac.kr:8091/junghyeonpark/20194475.git](http://sw-git.chosun.ac.kr:8091/junghyeonpark/20194475.git)

### 사용 라이센스

Opencv 라이브러리 - apache 2.0

Magenta 라이브러리 - apache 2.0

### 실행 과정 및 결과(입출력 화면 or 실행 결과)

![capture1.jpg](OSSP%20%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A9%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%2043de55d99a844380b93b47c2c5b4be1d/capture1.jpg)

↪️ image resizing 이후 결과 이미지

![capture4.jpg](OSSP%20%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A9%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%2043de55d99a844380b93b47c2c5b4be1d/capture4.jpg)

↪️ note-sequence 생성을 위한 설치 코드 실행 이미지

![capture2.jpg](OSSP%20%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A9%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%2043de55d99a844380b93b47c2c5b4be1d/capture2.jpg)

↪️ note-sequence 생성 결과

![capture5.jpg](OSSP%20%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A9%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%2043de55d99a844380b93b47c2c5b4be1d/capture5.jpg)

↪️ RNN을 이용한 멜로디 변형을 위한 설치 코드 결과

![capture3.jpg](OSSP%20%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A9%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%2043de55d99a844380b93b47c2c5b4be1d/capture3.jpg)

↪️ RNN을 이용한 note-sequence변형 결과

### 참고 오픈소스

**Magenta tutorial**

[https://colab.research.google.com/notebooks/magenta/hello_magenta/hello_magenta.ipynb](https://colab.research.google.com/notebooks/magenta/hello_magenta/hello_magenta.ipynb)

### 참고 지식

🔸**Hue, Saturation, Value**

H ➡️ 색상 ➡️ 0~360 ➡️ opencv에서는 1/2값인 0~180만 사용 ➡️ 0에 가까울 수록 장파장

S ➡️ 채도 ➡️ 색의 진하기  ➡️ opencv기준 0~255 ➡️ 값이 클 수록 고채도

V ➡️ 명도 ➡️ 색의 밝기 ➡️ opencv 기준 0~255 ➡️ 값이 클 수록 고명도

🔸**색상과 감정의 상관관계**

장파장(난색), 고채도, 고명도일 수록 빠른 시간감과 비례한다.

장파장(난색), 고채도, 고명도일 수록 흥분감을 불러일으킨다.

🔸ptich? Midi에서 음의 높낮이를 나타낸다.

🔸velocity? 볼륨 크기

### 코드 작성 및 변경 부분

```python
<opencv를 이용한 H,S,V 분리, 이미지 Resizing>

import cv2
from google.colab.patches import cv2_imshow
import numpy as np

src = cv2.imread('/content/sample_data/sample3.jpeg')
cv2_imshow(src)
print(src.shape)

src2 = cv2.resize(src,(10,3),interpolation=cv2.INTER_LANCZOS4)
print(src2.shape)

hsv = cv2.cvtColor(src2, cv2.COLOR_BGR2HSV)
h,s,v = cv2.split(hsv)
```

```python
<색상은 장파,중파,단파 3가지 영역으로, 채도와 명도는 각각 2가지 영역으로 나누어
색상,채도,명도 순으로 우선시하여 12개의 영역에 0.2초부터 1.3까지 0.1초 간격으로
 매칭한 코드>

from note_seq.protobuf import music_pb2

my_music = music_pb2.NoteSequence()

r_arr = np.zeros((3,10))  # r_arr => running time =  end_time - start_time 
#print(r_arr)

for j in range (0,3):
  for i in range (0,10):
    if (0<= h[j][i] <=25) or ( 155<= h[j][i] <= 180):   # h1
      if 128 <= s[j][i] <= 255:
        if 128 <= v[j][i] <=255:
          r_arr[j][i] = 0.2
        else:                 # 0 <= v[0][i] <= 127
          r_arr[j][i]=0.3
      else:                   # 0<= s[0][i] <=127
        if 128 <= v[j][i] <=255:
          r_arr[j][i] = 0.4
        else:                 # 0 <= v[0][i] <= 127
          r_arr[j][i]=0.5
      
    elif (26<= h[j][i] <=85):   # h2
      if 128 <= s[j][i] <= 255:
        if 128 <= v[j][i] <=255:
          r_arr[j][i] = 0.6
        else:                 
          r_arr[j][i]=0.7
      else:                   
        if 128 <= v[j][i] <=255:
          r_arr[j][i] = 0.8
        else:                 
          r_arr[j][i]=0.9

    elif(86<= h[j][i] <=154):   # h3
      if 128 <= s[j][i] <= 255:
        if 128 <= v[j][i] <=255:
          r_arr[j][i] = 1.0
        else:                 
          r_arr[j][i]=1.1
      else:                   
        if 128 <= v[j][i] <=255:
          r_arr[j][i] = 1.2
        else:                 
          r_arr[j][i]=1.3
```

```python
<채도와 명도 모두 255부터 28씩 줄어가도록하여 9개의 범주 생성하고
	다시 고채도, 고명도 순으로 연결하여 총 81개의 범주를 
	높은 음의 pitch부터 연결시켰다.>

tp_arr = [255,226,197,168,139,110,81,52,23] #matching s,v about pitch 
p_arr = np.zeros((3,10))  #pitch array

for p in range(0,3):
  for k in range (0,10):
    for m in range(0,9):   #s:채도
      for n in range(0,9):  #v:명도
        if (tp_arr[m]-28) <= s[p][k] <= tp_arr[m]:
            if (tp_arr[n]-28) <= v[p][k] <= tp_arr[n]:
              p_arr[p][k]= 106 - ((m+1)*(n+1))
```

```python
<note sequence 작성 코드>

p_arr = np.int64(p_arr) #type 변환

start = 0.0
for i in range (0,10):
  my_music.notes.add( pitch = p_arr[0][i], start_time= start , end_time= start + r_arr[0][i], program=0, velocity=80)
  start = start +r_arr[0][i]

start = 0.0
for i in range (0,10):
  my_music.notes.add( pitch = p_arr[1][i], start_time= start , end_time= start + r_arr[1][i] ,program=0, velocity=80)
  start = start +r_arr[1][i]

start = 0.0
for i in range (0,10):
  my_music.notes.add( pitch = p_arr[2][i], start_time= start , end_time= start + r_arr[2][i] ,program=0, velocity=80)
  start = start +r_arr[2][i]

my_music.tempos.add(qpm=60);

# This is a colab utility method that visualizes a NoteSequence.
note_seq.plot_sequence(my_music)

# This is a colab utility method that plays a NoteSequence.
note_seq.play_sequence(my_music,synth=note_seq.fluidsynth)
```

### 출처에 대한 참고 문헌 목록

**note-sequence에 관한 변수 설명 github**

[https://github.com/magenta/note-seq/blob/main/note_seq/protobuf/music.proto#L27](https://github.com/magenta/note-seq/blob/main/note_seq/protobuf/music.proto#L27)

**hsv 색상표 분석 관련 문헌**

[https://subscription.packtpub.com/book/data/9781789537147/1/ch01lvl1sec09/object-detection-using-color-in-hsv](https://subscription.packtpub.com/book/data/9781789537147/1/ch01lvl1sec09/object-detection-using-color-in-hsv)

### 느낀점

구현하고자 하는 기능에 맞는 라이브러리를 찾는 것이 처음 맞딱뜨린 난관이였고, 그 다음은 라이브러리에 대한 변수를 해석하느라 시간을 보냈었는데, 무엇보다 어려움을 겪었던 파트는 색상 차원을 소리 차원으로 옮기는 과정이었다. 

색상, 명도, 채도를 추출하고 감정과의 상관 관계를 토대로 연결 짓고자 하였으나, 복합적인 상관 관계를 가진 탓에 H, S, V 중 어느 것을 우선으로 두어 매칭할 것인가에 대한 고민이 가장 컸다.  각 분야에 대한 전문 지식의 부족으로 협업의 필요성을 절실히 느끼게 되었다. 
여력이 된다면, 조금 더 체계적인 근거를 토대로 코드를 다듬고, 그림에서 엣지까지 검출하여 음악적 요소와 연결한 다음, 실제 사용자들이 이용할 수 있는 웹페이지로 구성하고 싶은 바람이 있다.

그럼에도 이번 수업을 통해 여러가지 라이선스에 대한 정보와 오픈소스 활용법에 대한 기초적인 지식을 익힐 수 있어서 도움이 되었다.